Controller - приёмная
Знает кого позвать, но не принимает решения

Это входная точка в приложении
Принимает HTTP запросы (GET, POST, PUT, DELETE)
Возвращает HTTP ответы

(GET /api/customers) - дай список всех покупателей
(POST /api/customers) - создай нового покупателя

Получает JSON от клиента к примеру через Postman или браузер
Вызывает соответствующий Service
Возвращает результат клиенту

НЕ содержит бизнес-логику
НЕ работает с базой напрямую
НЕ валидирует сложные правила

------------------------------------------------------------------
Model (Формы/Бланки)

Разделение на Еntity и DTO даёт
Безопасность: не показываем клиенту внутренние поля
Гибкость: меняем базу без изменения API
Производительность: отправляем только нужные данные

------------------------------------------------------------------
Entity - паспорт для базы данных

Это отражение таблицы базы данных в Java классе
Хранит данные в базе
Все поля должны быть указаны как в базе данных

------------------------------------------------------------------
DTO - анкета для API

Упрощенная версия Entity для обмена данными
Нужна для безопасной передачи данных через API

НЕ содержит: id, пароли, служебные поля

------------------------------------------------------------------
Repository - склад
Знает что где лежит, но не решает что с этим делать

Единственный слой который общается с базой данных
Выполняет операции (Create, Read, Update, Delete) CRUD
Использует Spring Data JPA

Примеры запросов:
Сохрани этого покупателя в базу
Найди всех покупателей с email gmail.com
Удали покупателя с ID 5

Маппит Java объекты из/в SQL таблицы
Генерирует SQL запросы автоматически
Возвращает данные Service

Содержит:
Методы доступа к данным
Кастомные SQL запросы
Только простые операции с базой данных

------------------------------------------------------------------
Service - отдел логики
Принимает решения, знает процессы компании

Мозг приложения в котором находится бизнес логика
Содержит правила и процессы
Координирует работу между разными частями

К примеру при создании заказа проверяет есть ли товар на складе
Если покупатель VIP - примени скидку 10%
При отмене заказа верни товары на склад

Получает данные от Controller
Применяет бизнес правила
Вызывает Repository для хранения
Возвращает результат Controller

Содержит:
Валидацию данных
Расчеты (скидки, суммы)
Сложную логику обработки
Работу с несколькими Repository

------------------------------------------------------------------
Exception - отдел жалоб

Обработка ошибок в одном месте
Преобразование исключений в понятные HTTP ответы

Пример:
Вместо ошибки 500 (серверная ошибка) возвращаем 404 (не найдено) с понятным сообщением

Ловит исключения по всему приложению
Преобразует в стандартный JSON формат
Возвращает корректный HTTP статус

------------------------------------------------------------------

Полный поток данных:

Postman
    ↓
(HTTP + JSON)
Postman отправляет запрос:
Метод: GET/POST/PUT/DELETE
URL: http://localhost:8080/api/customers
Тело: JSON с данными
Цель: Отправить команду и данные в приложение
    ↓
Controller ("Приемная")
Controller принимает запрос:
@RestController понимает, что это REST запрос
@RequestMapping определяет КУДА пришел запрос
Spring автоматически преобразует JSON → Java объект
Цель: Принять запрос, понять ЧТО хочет клиент
    ↓
(DTO объект)
Controller передает DTO в Service:
Говорит Service создай нового покупателя с этими данными
DTO содержит ТОЛЬКО данные для бизнес-логики
Service получает чистые данные без HTTP "шума"
Цель: Отделить HTTP логику от бизнес-логики
    ↓
Service ("Менеджер")
    ↓
(Entity объект)
Service подготавливает данные для базы:
Валидирует данные (правильный email? есть имя?)
Применяет бизнес-правила (скидки, ограничения)
Преобразует DTO → Entity (добавляет служебные поля)
Говорит Repository: "Сохрани этого покупателя!"
Цель: Обработать данные по правилам бизнеса
    ↓
Repository ("Кладовщик")
    ↓
(SQL запрос)
Repository работает с базой:
Преобразует Entity объект → SQL команды
"INSERT INTO customers (name, email) VALUES (?, ?)"
Выполняет запрос через Hibernate/JDBC
Получает сгенерированный ID от базы
Цель: Надежно сохранить/получить данные из БД
    ↓
База данных
    ↑
(Результат)
База выполняет операцию:
Сохраняет данные в таблице
Возвращает результат (успех/ошибка)
Возвращает сгенерированные данные (ID, даты)
Цель: Надежное хранение и целостность данных
    ↑
Repository
    ↑
(Entity)
Repository возвращает результат:
"Операция выполнена, вот сохраненный объект"
Entity содержит ВСЕ поля из базы (ID, дата создания и т.д.)
Service получает полные данные для дальнейшей обработки
Цель: Передать подтверждение операции и полные данные
    ↑
Service
    ↑
(Обработанные данные)
Service завершает бизнес-процесс:
"Покупатель создан успешно!"
Может обогатить данные (статус, дополнительные расчеты)
Преобразует Entity → DTO (убирает служебные поля)
Передает чистый результат Controller
Цель: Вернуть клиенту ТОЛЬКО нужные ему данные
    ↑
Controller
    ↑
(DTO + HTTP ответ)
Controller формирует ответ:
Преобразует DTO → JSON
Устанавливает HTTP статус (200 OK, 201 Created)
Добавляет заголовки если нужно
Отправляет красивый JSON ответ
Цель: Вернуть клиенту понятный и структурированный ответ
    ↑
Postman
Клиент видит результат:
Статус: 201 Created
Тело: {"id": 1, "name": "Иван", "email": "ivan@test.ru"}
Понимает, что операция выполнена успешно
Цель: Дать клиенту четкий ответ о результате операции